---
title: "Netlogo to R Pipeline"
author: "Shannon Carter"
date: "March 11, 2019"
output: html_document
---

The goal here is to make a clean reproducible pipeline to transform Netlogo output into a tidy rectangular dataframe. Here, I import behavior space data (i.e., experiment results) from Netlogo to R. Netlogo's behavior space data comes in a wonky format, and the goal is to do as much of the tidying in R (vs. on spreadsheet) as possible. The data I've imported here does several 'runs' (multiple treatments and replicates) of an simulation testing effects of phenology on species interactions. There is summary data for each run and there's also time series info on size for each turtle/agent.

```{r setup, include = F}
knitr::opts_chunk$set(echo = T, warning = F)

## Set working directory and clear memory
setwd("C:\\Users\\Shannon\\Desktop\\GitHub Repos\\phenology-abm")
rm(list = ls(all = T))

## Load required packages
library(tidyverse)
library(reshape2)
library(RColorBrewer)
library(lme4)
#library(RNetLogo)    # maybe worthwhile looking into this, so far can't figure it out

## Load universal plotting elements
mytheme <- theme(panel.background = element_blank(),
                 panel.grid.minor = element_blank(), 
                 panel.grid.major = element_blank(),
                 axis.text  = element_text(size = rel(1.3), colour = "black"),
                 axis.title = element_text(size = rel(2.0)),
                 axis.line  = element_line(colour = "black"))

```

First, be sure you export behavior space data in "table" format. When the raw data is exported as a spreadsheet, it comes in a really gnarly format. R can't read it because it's not even close to rectangular, big header, mix of space delimited and bracket delimited. It's a mess. The table is still a bit messy, but much easier to wrangle.

```{r load table data}

test <- read.table("bs1_table.csv",
                   header = T,
                   sep = ',',
                   skip = 6,         # 6 header rows we don't need
                   quote = "\"",
                   fill = T)         # add blank fields if rows have unequal length

# [,1:12] are parameter values (some consistent across all, some representing trts)
# [,13:16] are the output we designated
str(test)  

```

First, let's rename columns and drop some that we don't need. I keep some columns that are the same across all model runs because it will be useful to call them later, especially since different runs of the experiment might have differetn values. Some columns will always be the same, or are irrelevant. These I drop. 
```{r}
# select and rename columns. new_name = old name. 
# renaming everything I keep, so can rename with select
test <- test %>% 
  select(run_num = X.run.number.,
         total_time = X.step.,
         n_fish = n.fishes,
         n_dfly = n.dflies,
         sync_dfly = var.hatch.dflies,   
         mean_dfly = mean.hatch.dflies, 
         surv_dfly = n.meta.dflies, 
         surv_fish = n.meta.fishes, 
         sizes_dfly = X.dfly.size.list..of.dflies, 
         sizes_fish = X.fish.size.list..of.fishes)

# extract and keep this for reference
params <- test[,1:8]
```

The 'sizes' columns has a time series of size for each individual. Let's separate that. This warning is ok. The last individual ends with double closed bracket, so we're just deleting that extra bracket, and still end up with the 50 individuals for each species that we expect.
```{r}
test <- test %>% 
  separate(sizes_dfly,                                      # separate sizes_dfly
           into = paste("d_", c(1:test$n_dfly), sep = ""),  # levels for new var
           sep = "]") %>%                                   # every ] marks a new ind
  separate(sizes_fish, 
           into = paste("f_", c(1:test$n_fish), sep = ""), 
           sep = "]")
```

Now, gather it so that individuals appear in rows instead of columns
```{r}
# first dragonflies. Need to be careful here or will get 
test_dfly <- test %>%
  select(run_num, d_1:d_50) %>% 
  unique(.) %>% 
  gather(d_1:d_50, key = "dfly_id", value = 'size_dfly') %>% 
  arrange(run_num)
  
# do separately for each sp, otherwise it will do full factorial pairing
test_fish <- test %>% 
  select(run_num, f_1:f_50) %>% 
  unique(.) %>% 
  gather(f_1:f_50, key = "fish_id", value = "size_fish") %>% 
  arrange(run_num)

test <- merge(test_dfly, test_fish, by = "run_num")
test <- left_join(test, params, by = "run_num")
```

```{r}
test$size_dfly <- gsub("[", "", test$size_dfly, fixed = T)
test$size_fish <- gsub("[", "", test$size_fish, fixed = T)
```


```{r}
test1 <- test %>% 
  separate(size_dfly,                                      # separate size_dfly
           into = paste("td_", c(0:test$total_time), sep = ""),  # levels for new var
           sep = " ") %>% 
  separate(size_fish,
           into = paste("tf_", c(0:test$total_time), sep = ""),
           sep = " ") #%>%
test1 <- test1 %>% 
  select(-td_0, tf_0)
test1 <- unique(test1)

```

```{r}
testb <- test1 %>% 
  summarise(max_size = pmax(test1$td_1:test1$td:149))

a <- filter(test1, run_num == 1, dfly_id == 'd_1')
```

Computationally, will not run on my computer. Can I work with time series saved in strings?

```{r}
test2 <- test1 %>% 
  group_by(run_num) %>% 
  gather(td_1:td_149, key = "time_d", value = 'current_size_dfly') %>%
  gather(tf_1:tf_149, key = "time_f", value = "current_size_fish") %>% 
  arrange(run_num)
```

